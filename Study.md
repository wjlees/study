# Functional Programming - Chapter 1
## 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다.

<br>

### 함수형 프로그래밍의 정의

1. 수학 함수를 사용하고 <u>**부수 효과**</u>(side effect)를 피하는 것이 특징인 프로그래밍 패러다임
2. 부수 효과 없이 <u>**순수 함수**</u>(pure function)만 사용하는 프로그래밍 스타일

**부수 효과** 는 함수가 리턴값 이외에 하는 모든 일을 말합니다. 예를 들어 메일 보내기나 전역 상태 수정과 같은 동작을 의미합니다.
**순수 함수** 는 인자에만 의존하고 부수 효과가 없는 함수입니다. 인자에만 의존한다는 말은 같은 인자를 넣으면 항상 같은 결과를 돌려준다는 말입니다.

정의에 따르면 함수형 프로그래머는 항상 부수 효과를 피하고 순수 함수만 사용해야 할 것 같지만, 실제 함수형 프로그래머는 부수 효과와 순수하지 않은 함수를 사용합니다.

### 실용적인 측면에서 함수형 프로그래밍 정의의 문제점
1. 부수 효과는 필요하다.  
   부수 효과는 소프트웨어를 실행하는 이유입니다. 이메일을 전송하지 않는 이메일 전송 소프트웨어는 의미가 없습니다. 부수 효과도 필요할 때는 써야합니다.
2. 함수형 프로그래밍은 부수 효과를 잘 다룰 수 있다.  
   함수형 프로그래머는 순수하지 않은 함수도 사용합니다. 또한 순수하지 않은 함수를 잘 다룰 수 있는 기술이 많이 있습니다.
3. 함수형 프로그래밍은 실용적이다.  
   정의에서는 함수형 프로그래밍이 수학적이라 실제 개발에서는 잘 사용되지 않는 것처럼 느껴지지만, 함수형 프로그래밍으로 잘 만들어진 좋은 소프트웨어가 많이 있습니다.

이 책에서는 일반적인 함수형 프로그래밍의 정의를 쓰지 않습니다.  
**함수형 사고** 라는 단어를 사용하고 있고, 이는 함수형 프로그래머가 소프트웨어 문제를 해결하기 위해 사용하는 기술과 생각을 말합니다.  
이 책에서 다루는 내용은 함수형 프로그래밍을 쓰고 있는 프로그래머가 가진 생각의 흐름, 시각을 정리한 내용입니다. 

그 중 가장 중요하다고 생각하는 **액션과 계산, 데이터를 구분하여 생각하기** 에 대해서 간략하게 설명하겠습니다.

### 액션과 계산, 데이터 구분하기 1

함수형 프로그래머는 코드를 **액션**과 **계산**, **데이터** 세 분류로 나눕니다.  
아래 코드를 분류해 봅시다.
```
1. { “firstname”: “Eric”, “lastname”: “Normand” }
2. sendEmail(to, from, subject, body)
3. sum(numbers)
4. saveUserDB(user)
5. string_length(str)
6. getCurrentTime()
7. [1, 10, 2, 45, 3, 98]
```

**액션**은 호출하는 시점과 횟수에 의존합니다.  

**계산**이나 **데이터**는 부르는 시점이나 횟수가 중요하지 않습니다.  

**계산**은 실행 가능하고, **데이터**는 실행 가능하지 않습니다.  

<br>

- 액션
```
sendEmail(to, from, subject, body)
saveUserDB(user)
getCurrentTime()
```
- 계산
```
sum(numbers)
string_length(str)
```
- 데이터
```
{ “firstname”: “Eric”, “lastname”: “Normand” }
[1, 10, 2, 45, 3, 98]
```


일반적으로 액션보다는 계산이 쓰기 쉽고, 계산보다는 데이터가 쓰기 쉽다고 생각합니다. 결과적으로 가장 쓰기 좋은 것은 데이터입니다.

### 액션과 계산, 데이터 구분하기 2

JIRA 에서 Done 처리하면 이메일을 통해 알려주는 과정
1. **사용자가 Done 표시를 함**  
   UI 이벤트인데 실행 횟수에 의존하기 때문에 **액션**입니다.
2. **클라이언트가 서버로 메시지를 보냄**  
   메시지를 보내는 것도 **액션**입니다. 메시지 자체는 나중에 서버에서 해석해야 하는 값이기 때문에 **데이터**입니다.
3. **서버가 메시지를 받음**  
   메시지를 받는 것은 횟수에 의존하므로 **액션**입니다.
4. **서버가 데이터베이스를 변경**  
   내부 상태를 바꾸는 것은 **액션**입니다.
5. **서버가 누구에게 알림을 보낼지 결정**  
   결정하는 것은 **계산**입니다. 입력값이 같다면 서버는 항상 같은 결정을 내리기 때문입니다.
6. **서버가 이메일로 알림을 보냄**  
   이메일 보내기는 **액션**입니다. 같은 메일을 한 번 보내는 것과 두번 보내는 것은 다릅니다.

**액션**, **계산**, **데이터를** 구분하면 분산 시스템에서의 여러 문제점을 해결할 수 있습니다.

**3장**부터 설명할 내용이 이와 같이 코드를 구분하는 이유와 방법, 장점에 대한 내용입니다.

### 액션과 계산, 데이터의 정리
1. **액션**  
   액션은 실행 시점이나 횟수 또는 둘 다에 의존합니다.
   긴급한 메일을 오늘 보내는 것과 내일 보내는 것은 다릅니다.
   같은 메일을 10번 보내는 것과 한 번 보내는 것 또는 보내지 않는 것 역시 다릅니다.
1. **계산**  
   계산은 입력값으로 출력값을 만드는 것입니다. 같은 입력값을 가지고 계산하면 항상 같은 결과값이 나옵니다. 언제, 어디서 계산해도 결과는 같고 외부에 영향을 주지 않습니다. 테스트하기 쉽고 언제 몇번을 불러도 안전합니다.
2. **데이터**  
   데이터는 이벤트에 대해 기록한 사실입니다. 데이터는 실행하는 코드만큼 복잡하지 않기 때문에 다른 것과 구분됩니다.
   실행하지 않아도 데이터 자체로 의미가 있고 여러 형태로 해석 가능합니다.

#

# Functional Programming - Chapter 2
## 현실에서의 함수형 사고

### 토니 피자  
토니는 피자 가게를 운영하고 있습니다. 혼자서는 운영이 힘들어 로봇을 사용하고자 합니다. 로봇은 함수형 사고를 하고, 자바스크립트로 프로그래밍 되어 있습니다.
토니의 가게에서 어떻게 함수형 사고를 사용했는지 살펴보도록 하겠습니다.  
아래는 토니가 적용한 함수형 사고의 기술들입니다.
이 책에서는 크게 아래와 같은 내용들을 다루게 될 것입니다. 

**파트 1: 액션과 계산, 데이터**  
1. 액션과 계산, 데이터의 구분
2. 계층형 설계

**파트 2: 일급 추상**  
1. 타임라인 다이어그램
2. 일급 함수(함수를 인자로 받는) 사용

### 파트 1-1. 액션과 계산, 데이터의 구분
토니가 만든 코드도 액션과 계산, 데이터로 나눌 수 있습니다.
1. 액션  
액션은 호출 횟수와 시점에 의존하는 것입니다. 오븐이나 배달차 같은 자원과 요리 재료를 사용하는 것은 액션입니다. 액션은 사용할 때 조심해야 합니다.  
ex) 반죽 펴기, 피자 배달, 재료 주문
2. 계산  
어떤 것을 결정하거나 계획하는 것은 계산입니다. 계산은 실행해도 다른 곳에 영향을 주지 않습니다. 계산은 아무 때나 사용해도 주방이 엉망진창 될 걱정이 없습니다.  
ex) 조리법에 나온 것을 두배로 만들기, 쇼핑 목록 결정
3. 데이터  
토니는 변경 불가능한 데이터를 가능한 많이 쓰려고 합니다. 결제, 재고, 피자 조리법 같은 것이 데이터입니다. 데이터는 유연하므로 다양하게 사용 가능합니다.  
ex) 고객 주문, 영수증, 조리법

### 파트 1-2. 계층화 설계 맛보기

코드를 변경할 때 드는 비용을 줄이기 위해 함수형 사고로 코드를 구성하려고 합니다. 변경 가능성에 따라 코드를 나눠봅니다. 위쪽으로 갈수록 자주 바뀌는 코드를, 아래쪽으로 갈수록 자주 바뀌지 않는 코드를 위치시킵니다.

가장 아래쪽에는 배열이나 객체 같은 언어 기능을, 가운데에는 바뀔 수도 있지만 자주 바뀌지 않는 피자 조리에 대한 내용을 둡니다. 가장 위쪽에는 이번 주 메뉴와 같이 자주 바뀌는 사업적인 내용을 둡니다.  

| [ 피자 주방 레이어 ] | [ 창고 레이어 ] | [ 메인 레이어 ] |
| :--- | :--- | :---: |
| **이번 주 메뉴** <br> - 이번 주 특별 메뉴를 위한 조리법 | **이번 주 사야 할 것** <br> - 재료를 어디서 구입할지 결정 | **비즈니스 규칙** |
| **피자 만들기** <br> - 조리법 순서 | **재료 목록** <br> - 재료 목록에 대한 동작 | **도메인 규칙** |
| **자바스크립트** <br> - 객체 <br> - 배열 | **자바스크립트** <br> - 객체 <br> - 숫자 | **기술 스택** |

각 계층은 그 아래에 있는 계층을 기반으로 만들어집니다. 이런 구조라면 쉽게 변경 가능합니다. 가장 위에 있는 코드는 의존성이 거의 없기 때문에 쉽게 바꿀 수 있습니다. 아래에 있는 코드들은 위에 있는 코드보다 의존성이 많아 바꾸기 어렵지만 자주 바뀌지 않습니다.  
계층형 설계로 만든 코드는 테스트, 재사용, 유지보수가 쉽습니다. 8장과 9장에서 자세히 알아봅니다.

### 파트 2-1. 타임라인 다이어그램
**타임라인 다이어그램**은 로봇 한 대가 피자를 만들기 위한 **액션**들을 보여줍니다.

- 치즈 피자 만들기  
  - ```주문 접수```  
  - ```반죽 만들기``` - 준비  
  - ```반죽 펴기``` - 사용  
  - ```소스 만들기``` - 준비  
  - ```소스 뿌리기``` - 사용  
  - ```치즈 갈기``` - 준비  
  - ```치즈 뿌리기``` - 사용  
  - ```오븐에 넣기```  
  - ```10분 기다리기```  
  - ```서빙```  

타임라인 다이어그램을 사용하면 액션이 시간 순서에 따라 어떻게 실행되는지 볼 수 있습니다. 액션은 실행 시점에 의존하기 때문에 실행 순서가 중요합니다. 액션을 다이어그램으로 그리는 법은 15장에서 설명할 예정입니다.  

로봇 한 대로 피자를 만들기에는 빠르지 않아 로봇 세 대로 만들고자 합니다. 여러 대의 로봇이 함께 일을 하는 것은 분산 시스템을 의미합니다. 분산 시스템에서 독립된 액션의 실행 순서는 어떻게 될지 모릅니다.

타임라인을 아래와 같이 수정했습니다. 로봇 세 대가 같이 일하기 때문에 더 빨리 만들 수 있을 것입니다.

- 치즈 피자 만들기  
  - ```주문 접수```  
  - ```반죽 만들기``` | ```소스 만들기``` | ```치즈 갈기```  
  - ```반죽 펴기```  
  - ```소스 뿌리기```  
  - ```치즈 뿌리기```  
  - ```오븐에 넣기```  
  - ```10분 기다리기```  
  - ```서빙```  

하지만 위와 같이 타임라인을 수정했을 때 많은 피자가 잘못 나올 수 있습니다.

- 치즈 피자 만들기 (실패1)  
  - ```주문 접수```  
  - ```반죽 만들기``` | ```소스 만들기``` | ```치즈 갈기(시작)```  
  - ```반죽 펴기```  
  - ```소스 뿌리기```  
  - ```치즈 뿌리기```  
  - ```오븐에 넣기``` | ```치즈 갈기(완료)```   
  - ```10분 기다리기```  
  - ```서빙```  

- 치즈 피자 만들기 (실패2)  
  - ```주문 접수```  
  - ```반죽 만들기(시작)``` | ```소스 만들기``` | ```치즈 갈기```  
  - ```반죽 펴기```  
  - ```소스 뿌리기```  
  - ```치즈 뿌리기``` | ```반죽 만들기(완료)```   
  - ```오븐에 넣기```
  - ```10분 기다리기```  
  - ```서빙```  

타임라인을 서로 맞추지 않은 분산 시스템은 예측 불가능한 순서로 실행됩니다. 로봇들이 반죽, 치즈 소스 준비가 끝나면 피자를 만들도록 해야합니다.

### 파트 2-2. 타임라인 커팅

타임라인 커팅은 17장에서 다룰 예정입니다. 간단히 알아봅시다.

타임라인 커팅은 여러 타임라인이 동시에 진행될 때 서로 순서를 맞추는 방법입니다.  
타임라인 커팅은 고차 동작으로 구현합니다. 고차 동작은 10장에서 자세히 알아보겠습니다.  
타임라인 커팅을 아래와 같이 적용해봅시다.

- 치즈 피자 만들기  
  - ```주문 접수```  
  - ```반죽 만들기``` | ```소스 만들기``` | ```치즈 갈기```  
  ***
  - ```반죽 펴기```  
  - ```소스 뿌리기```  
  - ```치즈 뿌리기```  
  - ```오븐에 넣기```  
  - ```10분 기다리기```  
  - ```서빙```  

각 타임라인은 독립적으로 동작하고 작업이 완료되면 다른 타임라인이 끝나기를 기다리기 때문에 어떤 타임라인이 먼저 끝나도 괜찮습니다. 구현 방법에 대해서는 17장에서 설명할 예정입니다.

# Chapter 1~2 질문 및 의견

| 닉네임 | 질문 또는 의견 |
| :---: | --- |
화니 | 4p에 "함수형 프로그래밍이 시스템 의존성을 개선하는 데 좋다"라고 나와 있습니다. 어떤점에서 의존성을 개선하는데 좋은건가요?  
마크 | 데이터 계산 액션 이렇게 세개로 나눠진다는데 3개의 요소보다는 데이터는 액션과 계산 사이에 통신하는 매개체라는 생각이 드는데 맞을까요? 맞다면 3개의 요소보다는 두 종류의 함수가 있고 그 사이를 데이터가 연결해준다 가 좀 더 와닿는 표현 같아서요
태기 | 시작하는 챕터이니 만큼 특별한 내용은 없었던 것 같습니다. 하지만 "일급추상"이라던가 "액션"과 같은 용어는 들어보지 못했던 것이고 특히 "일급추상"에 대해서는 명확한 해설이 없어서 아쉬웠습니다.
신기 | 분산형 시스템 이야기가 많이 나오는데 앞으로 배우겠지만, 실제로 분산형 시스템에서 함수형 프로그래밍이 어떤식으로 활용되는지 간단한 예를 보여주시면 좋을 것 같습니다.
스시 | 2장에 피자관련 예시를 보니, DAG(방향성 비순환 그래프, Topology Sort : 위상정렬)랑 유사하다는 생각이 들었다. airflow에서도 dag가 진행되는 과정에서 task들이 분기되었다가 합쳐지기도 하는데, 이 부분은 airflow 강의 ppt를 참고해보는 것도 좋을 듯함.
티모 | 비즈니스 계층에 주로 액션이 들어갈 것 같은데, 테스트가 어떤식으로 가능할 지 궁금하네요.
잭슨 | 1장에서 액션과 계산, 데이터를 구분과정에서, 액션과 계산의 차이가 개념적으로는 이해하지만, 개발 상황에서의 복잡한 로직들에서 분리하는게 쉽지는 않을거 같아요! (3장에 소개가 되는거 같긴합니다!) 
마루 | 1,2장은 약간 에피타이저 반절 정도 먹은 느낌이네요 ㅋㅋ 3장까지 한번에 했으면 좋았겠지만 파이팅입니다!


1. 함수형 프로그래밍이 시스템 의존성을 개선하는데 좋다.  
   계층형 설계에 대한 내용으로 생각됩니다. 해당 내용은 8장과 9장에서 자세히 다룰 예정입니다.  
   제 생각에는 상태 변화를 일으키는 액션과, 그렇지 않은 계산 및 데이터로 구분할 수 있고, 액션을 줄이고 계산을 늘림으로써 의존성이 개선될 것 같습니다. 상태 변화를 일으키는 액션들 사이의 의존성에 대해서도, 타임라인 다이어그램으로 시각화하여 커팅과 같은 유용한 도구들을 통해서 좀 더 다루기가 쉬워지기 때문에 의존성 개선에 좋다고 말한 것 같습니다.
2. 데이터는 3개의 요소 중 하나라고 하기보다 액션과 계산 사이에 통신하는 매개체라고 생각된다.  
   액션 및 계산과 같은 함수들 사이의 매개체라는 표현도 맞다고 생각합니다. 하지만 함수들 사이의 매개체라고 했을 때, 함수를 호출할 때 전달되는 인자로 생각한다면, 함수도 인자로 전달될 수 있기 때문에 오히려 헷갈릴 것 같습니다. 이 책에서 구분하는 **액션과 계산, 데이터**는 성질에 따라, 의존성에 따라 구분한 것으로 생각됩니다. 액션은 실질적으로 이벤트를 발생시키는 일입니다. 계산은 이를 위해 데이터를 가지고 결과값을 도출합니다. 데이터는 실행되는 것은 아니지만 이벤트에 대한 기록입니다. **코드가 어떻게 이루어져 있는지**를 설명함에 있어서 이 책에서는 코드는 3가지 요소가 있다 라고 설명하는 것이고, 그 중 데이터의 역할은 연결의 역할이다 라고 설명할 수 있을 것 같습니다.
3. 분산형 시스템의 예시  
   토니의 피자가게에서 여러 로봇들이 일하게 되는 시스템이 분산형 시스템입니다. 로봇은 결국 피자 만들기라는 큰 목표를 가지고 일하지만 각자 하게 되는 일은 다릅니다. 각각 다른 일을 하게 되고, 속도도 항상 다를 수 있지만 피자 만들기라는 일이 제대로 이루어지기 위해서 각각의 종료시점을 맞추는 커팅이라는 기술을 사용하게 됩니다. forkJoin 이나 mergeMap 의 동작으로 이해했습니다.
4. 액션의 테스트  
   액션 자체는 테스트하기 어렵고, 따라서 액션에서 최대한 계산을 많이 분리해서 경우의 수를 줄여 테스트를 쉽게 만드는 것이 4장, 5장의 내용인 것 같습니다. 많이 분리할수록 작게 만들수록 테스트하기 쉽고 이해하기 쉬워집니다.
